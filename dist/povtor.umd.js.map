{"version":3,"file":"povtor.umd.js","sources":["../src/index.ts"],"sourcesContent":["export type RetryAction = (...args: unknown[]) => Promise<unknown> | unknown;\n\nexport type GetRetryTimeout = (result?: RetryResult) => unknown;\nexport type RetryTimeout = number | GetRetryTimeout;\n\nexport type RetryTest = (value?: unknown, result?: RetryResult) => boolean;\n\n/** Settings of {@link retry} function. */\nexport interface RetrySettings {\n    /** A function that should be called. */\n    action: RetryAction;\n    /** An object that should be used as `this` when calling the action function. */\n    actionContext?: unknown;\n    /** An array of parameters that should be passed into the action function. */\n    actionParams?: unknown[];\n    /**\n     * An amount of milliseconds before first call of the action function.\n     * When the value is not specified or is negative, the action function will be called immediately first time.\n     */\n    delay?: number;\n    /**\n     * An array specifying amount and timeouts between repeated calls of the action function.\n     * Each item can be a number or a function (see `retryTimeout` setting for details).\n     * Has priority over `retryQty` and `retryTimeout` settings.\n     */\n    retryAttempts?: RetryTimeout[];\n    /**\n     * Maximum number of repeated calls of the action function. A negative value means no restriction.\n     * Default value is `-1`.\n     */\n    retryQty?: number;\n    /**\n     * A timeout between repeated calls of the action function, or a function that returns such timeout.\n     * A negative or non-number value means the repeat call will be made without delay (this is applied by default).\n     * If specified function returns `false` then retry process will be finished and result promise\n     * will be fulfilled or rejected depending on result of the last action's call.\n     */\n    retryTimeout?: RetryTimeout;\n    /**\n     * A boolean value or a function returning boolean value that specifies whether the action function\n     * should be called again when the action function throws an error or returned promise is rejected.\n     * When not specified the call of the action function will not be repeated on an error.\n     */\n    retryOnError?: boolean | RetryTest;\n    /**\n     * A boolean value or a function returning boolean value that specifies whether the action function\n     * should be called again after a made call. When not specified the action call will not be repeated.\n     */\n    retryTest?: boolean | RetryTest;\n    /**\n     * Time in milliseconds specifying how long retry process can last\n     * starting from call of `retry` function.\n     * Elapsed time is checked before each retry attempt and when the time exceeds the given limit\n     * process will be finished and result promise will be fulfilled or rejected\n     * depending on result of the last action's call.\n     * `0` or negative value means no limit.\n     */\n    timeLimit?: number;\n    [field: string]: unknown;\n}\n\nexport interface ValueResult {\n    /** Time in milliseconds when value was saved. */\n    time: number;\n    /** Result of action's call or value of promise fulfillment. */\n    value: unknown;\n}\n\nexport interface ErrorResult {\n    /** Error of action's call or value of promise rejection. */\n    error: unknown;\n    /** Time in milliseconds when error was saved. */\n    time: number;\n}\n\nexport type ActionCallResult = ValueResult | ErrorResult;\n\nexport interface WithPromiseField {\n    promise: Promise<unknown>;\n}\n\nexport interface RetryResult extends WithPromiseField {\n    /** Number of calls of the action function that have already made. */\n    attempt: number;\n    /** Last error or value of promise rejection. */\n    error: unknown;\n    /** Whether the last call of the action function is ended with error. */\n    isError: boolean;\n    /** Contains result of each call of the action function. */\n    result: ActionCallResult[];\n    /** Settings that were passed to `retry` function. */\n    settings: RetrySettings;\n    /** Time in milliseconds when `retry` function was called. */\n    startTime: number;\n    /** Function that can be used to stop the process of calls repeating. Returns value of `promise` field. */\n    stop: () => Promise<unknown>;\n    /** A boolean value that indicates whether the process of calls repeating is stopped. */\n    stopped: boolean;\n    /**\n     * A value of last successfull call of the action function. When the action function returns a promise,\n     * the value will be result of the promise fulfillment.\n     */\n    value: unknown;\n    /**\n     * A boolean value that indicates whether the action function is producing a result.\n     * Useful only when the action function returns a promise. Is set to `true` when the promise is pending.\n     */\n    valueWait: boolean;\n    /**\n     * A boolean value that indicates waiting of the next call of the action function.\n     * Is set to `true` during a timeout between calls.\n     */\n    wait: boolean;\n}\n\n/**\n * Call specified function and repeat calls depending on settings.\n *\n * @param settings\n *      Operation settings.\n */\nexport function retry(settings: RetrySettings): RetryResult {\n    let actionResult, resultReject, resultResolve, timeoutId;\n    // eslint-disable-next-line func-names, prefer-arrow-callback\n    const resultPromise = new Promise(function(resolve, reject) {\n        resultResolve = resolve;\n        resultReject = reject;\n    });\n    const callResultList: ActionCallResult[] = [];\n\n    const { retryTimeout } = settings;\n    let index = 0;\n    let stopped = false;\n\n    let attempts: number;\n    let { retryAttempts, timeLimit } = settings;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/prefer-optional-chain\n    if (retryAttempts && retryAttempts.length) {\n        attempts = retryAttempts.length + 1;\n    }\n    else {\n        retryAttempts = null;\n        const { retryQty } = settings;\n        if (typeof retryQty === 'number' && retryQty >= 0) {\n            attempts = retryQty + 1;\n        }\n        else {\n            attempts = -1;\n        }\n    }\n    if (typeof timeLimit !== 'number' || timeLimit < 0) {\n        timeLimit = 0;\n    }\n\n    function stopRetry(): Promise<unknown> {\n        if (! stopped) {\n            /* eslint-disable @typescript-eslint/no-use-before-define */\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                retryResult.wait = false;\n            }\n            stopped = retryResult.stopped = true;\n            if (! retryResult.valueWait) {\n                resultResolve(retryResult.value);\n            }\n            /* eslint-enable @typescript-eslint/no-use-before-define */\n        }\n\n        return resultPromise;\n    }\n\n    const startTime = new Date().getTime();\n    const retryResult: RetryResult = {\n        attempt: index,\n        error: actionResult,\n        isError: false,\n        promise: resultPromise,\n        result: callResultList,\n        settings,\n        startTime,\n        stop: stopRetry,\n        stopped: false,\n        value: actionResult,\n        valueWait: false,\n        wait: false\n    };\n\n    function retryAction(): void {\n        retryResult.attempt = ++index;\n        retryResult.wait = false;\n        retryResult.valueWait = true;\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            actionResult = settings.action.apply(settings.actionContext || null, settings.actionParams || []);\n            if (actionResult && typeof actionResult === 'object' && typeof actionResult.then === 'function') {\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                actionResult.then(onActionEnd, onActionError);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                onActionEnd(actionResult);\n            }\n        }\n        catch (e) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            onActionError(e);\n        }\n    }\n\n    function end(): void {\n        if (retryResult.isError) {\n            resultReject(retryResult.error);\n        }\n        else {\n            resultResolve(retryResult.value);\n        }\n    }\n\n    // eslint-disable-next-line consistent-return\n    function repeat(): void {\n        let timeout;\n        if (index) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            timeout = retryAttempts\n                ? retryAttempts.shift()\n                : retryTimeout;\n            if (typeof timeout === 'function') {\n                timeout = timeout(retryResult);\n                if (timeout === false) {\n                    return end();\n                }\n            }\n        }\n        else {\n            timeout = settings.delay;\n        }\n        if (attempts > 0) {\n            attempts--;\n        }\n        if (typeof timeout !== 'number' || timeout < 0) {\n            retryAction();\n        }\n        else {\n            retryResult.wait = true;\n            timeoutId = setTimeout(retryAction, timeout);\n        }\n    }\n\n    function next(test: unknown): void {\n        let proceed = test;\n        const result = {\n            time: new Date().getTime()\n        } as ActionCallResult;\n        let value;\n\n        if (retryResult.isError) {\n            value = (result as ErrorResult).error = retryResult.error;\n        }\n        else {\n            value = (result as ValueResult).value = retryResult.value;\n        }\n        retryResult.result.push(result);\n        retryResult.valueWait = false;\n\n        if (stopped || ! attempts) {\n            proceed = false;\n        }\n        else if (typeof proceed === 'function') {\n            proceed = proceed(value, retryResult);\n        }\n        if (proceed && (! timeLimit || new Date().getTime() - startTime <= timeLimit)) {\n            repeat();\n        }\n        else {\n            end();\n        }\n    }\n\n    function onActionEnd(value: unknown): void {\n        retryResult.value = value;\n        retryResult.isError = false;\n        next(settings.retryTest);\n    }\n\n    function onActionError(reason: unknown): void {\n        retryResult.error = reason;\n        retryResult.isError = true;\n        next(settings.retryOnError);\n    }\n\n    repeat();\n\n    return retryResult;\n}\n\n/**\n * Return value of `promise` field of the passed object.\n *\n * @param obj\n *      Object whose field should be returned.\n * @return\n *      Value of `promise` field of the passed object.\n * @author Denis Sikuler\n */\nexport function getPromiseField(obj: WithPromiseField): Promise<unknown> {\n    return obj.promise;\n}\n"],"names":["settings","actionResult","resultReject","resultResolve","timeoutId","attempts","resultPromise","Promise","resolve","reject","index","stopped","retryAttempts","length","retryQty","timeLimit","startTime","Date","getTime","retryResult","attempt","error","isError","promise","result","stop","clearTimeout","wait","valueWait","value","retryAction","action","apply","actionContext","actionParams","then","onActionEnd","onActionError","e","end","repeat","timeout","shift","retryTimeout","delay","setTimeout","next","test","proceed","time","push","retryTest","reason","retryOnError","obj"],"mappings":"0MAyHsBA,OACdC,EAAcC,EAAcC,EAAeC,EAY3CC,EAVEC,EAAgB,IAAIC,QAAQ,SAASC,EAASC,GAChDN,EAAgBK,EAChBN,EAAeO,qBAKfC,EAAQ,EACRC,GAAU,qCAKVC,GAAiBA,EAAcC,OAC/BR,EAAWO,EAAcC,OAAS,MAEjC,CACDD,EAAgB,KACRE,iBAEJT,EADoB,iBAAbS,GAAyBA,GAAY,EACjCA,EAAW,GAGV,GAGK,iBAAdC,GAA0BA,EAAY,KAC7CA,EAAY,OAoBVC,GAAY,IAAIC,MAAOC,UACvBC,EAA2B,CAC7BC,QAASV,EACTW,MAAOpB,EACPqB,SAAS,EACTC,QAASjB,EACTkB,OAjDuC,YAkDvCxB,YACAgB,EACAS,uBAzBMd,IAEEP,IACAsB,aAAatB,GACbe,EAAYQ,MAAO,GAEvBhB,EAAUQ,EAAYR,SAAU,EAC1BQ,EAAYS,WACdzB,EAAcgB,EAAYU,QAK3BvB,GAaPK,SAAS,EACTkB,MAAO5B,EACP2B,WAAW,EACXD,MAAM,YAGDG,IACLX,EAAYC,UAAYV,EACxBS,EAAYQ,MAAO,EACnBR,EAAYS,WAAY,OAGpB3B,EAAeD,EAAS+B,OAAOC,MAAMhC,EAASiC,eAAiB,KAAMjC,EAASkC,cAAgB,MAClD,iBAAjBjC,GAA0D,mBAAtBA,EAAakC,KAExElC,EAAakC,KAAKC,EAAaC,GAI/BD,EAAYnC,GAGpB,MAAOqC,GAEHD,EAAcC,aAIbC,IACDpB,EAAYG,QACZpB,EAAaiB,EAAYE,OAGzBlB,EAAcgB,EAAYU,gBAKzBW,QACDC,KACA/B,MAKuB,mBAHvB+B,EAAU7B,EACJA,EAAc8B,QACdC,KAGc,KADhBF,EAAUA,EAAQtB,WAEPoB,SAKfE,EAAUzC,EAAS4C,MAEnBvC,EAAW,GACXA,IAEmB,iBAAZoC,GAAwBA,EAAU,EACzCX,KAGAX,EAAYQ,MAAO,EACnBvB,EAAYyC,WAAWf,EAAaW,aAInCK,EAAKC,OAKNlB,EAJAmB,EAAUD,EACRvB,EAAS,CACXyB,MAAM,IAAIhC,MAAOC,WAKjBW,EADAV,EAAYG,QACHE,EAAuBH,MAAQF,EAAYE,MAG3CG,EAAuBK,MAAQV,EAAYU,MAExDV,EAAYK,OAAO0B,KAAK1B,GACxBL,EAAYS,WAAY,EAEpBjB,IAAaN,EACb2C,GAAU,EAEc,mBAAZA,IACZA,EAAUA,EAAQnB,EAAOV,IAEzB6B,KAAcjC,IAAa,IAAIE,MAAOC,UAAYF,GAAaD,GAC/DyB,IAGAD,aAICH,EAAYP,GACjBV,EAAYU,MAAQA,EACpBV,EAAYG,SAAU,EACtBwB,EAAK9C,EAASmD,oBAGTd,EAAce,GACnBjC,EAAYE,MAAQ+B,EACpBjC,EAAYG,SAAU,EACtBwB,EAAK9C,EAASqD,qBAGlBb,IAEOrB,8BAYqBmC,UACrBA,EAAI/B"}